#ifndef SILENTDATA_ENCLAVE_SGX_ERROR_MESSAGE_H
#define SILENTDATA_ENCLAVE_SGX_ERROR_MESSAGE_H

#include <map>
#include <string>

#include "sgx_error.h"

#include "enclave/core_status_codes.h"

struct sgx_status_info
{
    core_status_code core_status;
    std::string name;
    std::string message;
};

const std::map<sgx_status_t, sgx_status_info> sgx_status_map = {
    {SGX_ERROR_UNEXPECTED, {kSGXError, "SGX_ERROR_UNEXPECTED", "Unexpected error occurred."}},
    {SGX_ERROR_INVALID_PARAMETER,
     {kSGXInvalidParameter, "SGX_ERROR_INVALID_PARAMETER", "Invalid parameter."}},
    {SGX_ERROR_OUT_OF_MEMORY, {kSGXOutOfMemory, "SGX_ERROR_OUT_OF_MEMORY", "Out of memory."}},
    {SGX_ERROR_ENCLAVE_LOST,
     {kSGXEnclaveError, "SGX_ERROR_ENCLAVE_LOST", "Power transition occurred."}},
    {SGX_ERROR_INVALID_STATE,
     {kSGXEnclaveError,
      "SGX_ERROR_INVALID_STATE",
      "The API is invoked in incorrect order of state."}},
    {SGX_ERROR_FEATURE_NOT_SUPPORTED,
     {kSGXError, "SGX_ERROR_FEATURE_NOT_SUPPORTED", "The feature is not supported."}},
    {SGX_ERROR_INVALID_FUNCTION,
     {kSGXEnclaveError,
      "SGX_ERROR_INVALID_FUNCTION",
      "The ECALL or OCALL function index is incorrect."}},
    {SGX_ERROR_OUT_OF_TCS, {kSGXBusy, "SGX_ERROR_OUT_OF_TCS", "The enclave is out of TCS."}},
    {SGX_ERROR_ENCLAVE_CRASHED,
     {kSGXEnclaveCrashed, "SGX_ERROR_ENCLAVE_CRASHED", "The enclave has crashed."}},
    {SGX_ERROR_ECALL_NOT_ALLOWED,
     {kSGXEnclaveError,
      "SGX_ERROR_ECALL_NOT_ALLOWED",
      "ECALL not allowed at this time (not public or blocked by dynamic entry table or nested "
      "ECALL in global initialization)."}},
    {SGX_ERROR_STACK_OVERRUN,
     {kSGXStackOverrun, "SGX_ERROR_STACK_OVERRUN", "Stack overrun occurs within the enclave."}},
    {SGX_ERROR_UNDEFINED_SYMBOL,
     {kSGXEnclaveError, "SGX_ERROR_UNDEFINED_SYMBOL", "Enclave contains an undefined symbol."}},
    {SGX_ERROR_INVALID_ENCLAVE,
     {kSGXEnclaveInvalid, "SGX_ERROR_INVALID_ENCLAVE", "Invalid enclave image."}},
    {SGX_ERROR_INVALID_ENCLAVE_ID,
     {kSGXEnclaveInvalid, "SGX_ERROR_INVALID_ENCLAVE_ID", "Invalid enclave identification."}},
    {SGX_ERROR_INVALID_SIGNATURE,
     {kSGXEnclaveInvalid, "SGX_ERROR_INVALID_SIGNATURE", "Invalid enclave signature."}},
    {SGX_ERROR_NDEBUG_ENCLAVE,
     {kSGXNDebugEnclave,
      "SGX_ERROR_NDEBUG_ENCLAVE",
      "Enclave signed as product enclave and cannot be created as a debuggable enclave."}},
    {SGX_ERROR_OUT_OF_EPC, {kSGXEnclaveError, "SGX_ERROR_OUT_OF_EPC", "Out of EPC memory."}},
    {SGX_ERROR_NO_DEVICE, {kSGXPlatformError, "SGX_ERROR_NO_DEVICE", "Invalid SGX device."}},
    {SGX_ERROR_MEMORY_MAP_CONFLICT,
     {kSGXError, "SGX_ERROR_MEMORY_MAP_CONFLICE", "Memory map conflicted."}},
    {SGX_ERROR_INVALID_METADATA,
     {kSGXEnclaveInvalid, "SGX_ERROR_INVALID_METADATA", "Invalid enclave metadata."}},
    {SGX_ERROR_DEVICE_BUSY, {kSGXBusy, "SGX_ERROR_DEVICE_BUSY", "SGX device was busy."}},
    {SGX_ERROR_INVALID_VERSION,
     {kSGXEnclaveInvalid, "SGX_ERROR_INVALID_VERSION", "Enclave version was invalid."}},
    {SGX_ERROR_MODE_INCOMPATIBLE,
     {kSGXPlatformError,
      "SGX_ERROR_MODE_INCOMPATIBLE",
      "The target enclave (32/64 bit or HS/Sim) mode is incompatible with the uRTS mode."}},
    {SGX_ERROR_ENCLAVE_FILE_ACCESS,
     {kSGXEnclaveFileAccess, "SGX_ERROR_ENCLAVE_FILE_ACCESS", "Can't open enclave file."}},
    {SGX_ERROR_INVALID_MISC,
     {kSGXEnclaveInvalid,
      "SGX_ERROR_INVALID_MISC",
      "The MiscSelect or MiscMask settings are incorrect."}},
    {SGX_ERROR_INVALID_LAUNCH_TOKEN,
     {kSGXEnclaveInvalid, "SGX_ERROR_INVALID_LAUNCH_TOKEN", "The launch token is incorrect."}},
    {SGX_ERROR_MAC_MISMATCH,
     {kSGXCryptoError, "SGX_ERROR_MAC_MISMATCH", "Report verification error."}},
    {SGX_ERROR_INVALID_ATTRIBUTE,
     {kSGXEnclaveInvalid, "SGX_ERROR_INVALID_ATTRIBUTE", "Enclave was not authorized."}},
    {SGX_ERROR_INVALID_CPUSVN,
     {kSGXEnclaveInvalid,
      "SGX_ERROR_INVALID_CPUSVN",
      "The CPU SVN is beyond the CPU SVN value of the platform."}},
    {SGX_ERROR_INVALID_ISVSVN,
     {kSGXEnclaveInvalid,
      "SGX_ERROR_INVALID_ISVSVN",
      "The ISV SVN is greater than the ISV SVN value of the enclave."}},
    {SGX_ERROR_INVALID_KEYNAME,
     {kSGXEnclaveInvalid, "SGX_ERROR_INVALID_KEYNAME", "Unsupported key name value."}},
    {SGX_ERROR_SERVICE_UNAVAILABLE,
     {kSGXServiceError,
      "SGX_ERROR_SERVICE_UNAVAILABLE",
      "AE service does not respond or the requested service is not supported."}},
    {SGX_ERROR_SERVICE_TIMEOUT,
     {kSGXServiceError, "SGX_ERROR_SERVICE_TIMEOUT", "The request to AE service timed out."}},
    {SGX_ERROR_AE_INVALID_EPIDBLOB,
     {kSGXServiceError, "SGX_ERROR_AE_INVALID_EPIDBLOB", "Intel EPID blob verification error."}},
    {SGX_ERROR_SERVICE_INVALID_PRIVILEGE,
     {kSGXServiceError,
      "SGX_ERROR_INVALID_PRIVILEGE",
      "Enclave has no privilege to get a launch token."}},
    {SGX_ERROR_EPID_MEMBER_REVOKED,
     {kSGXPlatformError,
      "SGX_ERROR_EPID_MEMBER_REVOKED",
      "The Intel EPID group membership has been revoked, the platform is not trusted."}},
    {SGX_ERROR_UPDATE_NEEDED,
     {kSGXPlatformError, "SGX_ERROR_UPDATE_NEEDED", "Intel SGX requires update."}},
    {SGX_ERROR_NETWORK_FAILURE,
     {kSGXPlatformError,
      "SGX_ERROR_NETWORK_FAILURE",
      "Network connection or proxy setting issue encountered."}},
    {SGX_ERROR_AE_SESSION_INVALID,
     {kSGXServiceError,
      "SGX_ERROR_AE_SESSION_INVALID",
      "The AE session is invalid or ended by the server."}},
    {SGX_ERROR_BUSY,
     {kSGXBusy, "SGX_ERROR_BUSY", "The requested service is temporarily not available."}},
    {SGX_ERROR_MC_NOT_FOUND,
     {kSGXMCError,
      "SGX_ERROR_MC_NOT_FOUND",
      "The monotonic counter does not exist or has been invalidated."}},
    {SGX_ERROR_MC_NO_ACCESS_RIGHT,
     {kSGXMCError,
      "SGX_ERROR_MC_NO_ACCESS_RIGHT",
      "The caller does not have the access right to the specified VMC."}},
    {SGX_ERROR_MC_USED_UP,
     {kSGXMCError, "SGX_ERROR_MC_USED_UP", "No monotonic counter is available."}},
    {SGX_ERROR_MC_OVER_QUOTA,
     {kSGXMCError, "SGX_ERROR_MC_OVER_QUOTA", "Monotonic counters reached quota limit."}},
    {SGX_ERROR_KDF_MISMATCH,
     {kSGXCryptoError,
      "SGX_ERROR_KDF_MISMATCH",
      "Key derivation function does not match during key exchange."}},
    {SGX_ERROR_UNRECOGNIZED_PLATFORM,
     {kSGXPlatformError,
      "SGX_ERROR_UNRECOGNIZED_PLATFORM",
      "Intel EPID provisioning failed because the platform is not recognized by the back-end "
      "server."}},
    {SGX_ERROR_PCL_ENCRYPTED,
     {kSGXPCLError,
      "SGX_ERROR_PCL_ENCRYPTED",
      "PCL: Trying to load encypted enclave using the wrong API or with wrong parameters."}},
    {SGX_ERROR_PCL_NOT_ENCRYPTED,
     {kSGXPCLError,
      "SGX_ERROR_PCL_NOT_ENCRYPTED",
      "PCL: Trying to load unencypted enclave using API or parameters for encrypted enclave."}},
    {SGX_ERROR_PCL_MAC_MISMATCH,
     {kSGXPCLError,
      "SGX_ERROR_PCL_MAC_MISMATCH",
      "PCL: Runtime AES-GCM-128 MAC result of an encrypted section does not match the one at build "
      "time."}},
    {SGX_ERROR_PCL_SHA_MISMATCH,
     {kSGXPCLError,
      "SGX_ERROR_PCL_SHA_MISMATCH",
      "PCL: Runtime SHA256 of the decryption key does not match the one at build time."}},
    {SGX_ERROR_PCL_GUID_MISMATCH,
     {kSGXPCLError,
      "SGX_ERROR_PCL_GUID_MISMATCH",
      "PCL: The GUID in the decryption key sealed blob does not match the one at build time."}},
    {SGX_ERROR_FILE_BAD_STATUS,
     {kSGXFileError,
      "SGX_ERROR_FILE_BAD_STATUS",
      "The file is in a bad status. Run sgx_clearerr to try and fix it."}},
    {SGX_ERROR_FILE_NO_KEY_ID,
     {kSGXFileError,
      "SGX_ERROR_FILE_NO_KEY_ID",
      "The Key ID field is all zeros, cannot re-generate the encryption key."}},
    {SGX_ERROR_FILE_NAME_MISMATCH,
     {kSGXFileError,
      "SGX_ERROR_FILE_NAME_MISMATCH",
      "The current file name is different than the original file name."}},
    {SGX_ERROR_FILE_NOT_SGX_FILE,
     {kSGXFileError, "SGX_ERROR_FILE_NOT_SGX_FILE", "The file is not an Intel SGX file."}},
    {SGX_ERROR_FILE_CANT_OPEN_RECOVERY_FILE,
     {kSGXFileError,
      "SGX_ERROR_FILE_CANT_OPEN_RECOVERY_FILE",
      "The recovery file cannot be opened."}},
    {SGX_ERROR_FILE_CANT_WRITE_RECOVERY_FILE,
     {kSGXFileError,
      "SGX_ERROR_FILE_CANT_WRITE_RECOVERY_FILE",
      "A recovery file cannot be written."}},
    {SGX_ERROR_FILE_RECOVERY_NEEDED,
     {kSGXFileError,
      "SGX_ERROR_FILE_RECOVERY_NEEDED",
      "When opening the file, recovery is needed, but the recovery process failed."}},
    {SGX_ERROR_FILE_FLUSH_FAILED,
     {kSGXFileError, "SGX_ERROR_FILE_FLUSH_FAILED", "fflush operation failed."}},
    {SGX_ERROR_FILE_CLOSE_FAILED,
     {kSGXFileError, "SGX_ERROR_FILE_CLOSE_FAILED", "fclose operation failed."}},
    {SGX_ERROR_UNSUPPORTED_ATT_KEY_ID,
     {kSGXAttestationError,
      "SGX_ERROR_UNSUPPORTED_ATT_KEY_ID",
      "Platform quoting infrastructure does not support the key."}},
    {SGX_ERROR_ATT_KEY_CERTIFICATION_FAILURE,
     {kSGXAttestationError,
      "SGX_ERROR_ATT_KEY_CERTIFICATION_FAILURE",
      "Failed to generate and certify the attestation key."}},
    {SGX_ERROR_ATT_KEY_UNINITIALIZED,
     {kSGXAttestationError,
      "SGX_ERROR_ATT_KEY_UNINITIALIZED",
      "The platform quoting infrastructure does not have the attestation key available to generate "
      "a quote."}},
    {SGX_ERROR_INVALID_ATT_KEY_CERT_DATA,
     {kSGXAttestationError,
      "SGX_ERROR_ATT_KEY_CERT_DATA",
      "The data returned by the sgx_get_quote_config of the platform library is invalid."}},
    {SGX_ERROR_PLATFORM_CERT_UNAVAILABLE,
     {kSGXAttestationError,
      "SGX_ERROR_PLATFORM_CERT_UNAVAILABLE",
      "The PCK Cert for the platform is not available."}}};

std::string sgx_error_message(const std::string &method, const sgx_status_t &status);

inline core_status_code sgx_error_status(const sgx_status_t &status)
{
    if (sgx_status_map.find(status) != sgx_status_map.end())
    {
        return sgx_status_map.at(status).core_status;
    }
    return kSGXError;
}

#endif
